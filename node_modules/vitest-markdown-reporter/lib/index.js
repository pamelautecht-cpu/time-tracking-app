var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
import { accessSync } from "fs";
import { writeFile, mkdir } from "fs/promises";
import { dirname, resolve } from "path";
import { summary } from "@actions/core";

// src/log.ts
var name = "vitest-markdown-reporter";
var Logger = class {
  constructor(silent = false) {
    this.info = (message) => {
      if (!this.silent) {
        console.log(`
${name}: ${message}`);
      }
    };
    this.error = (message) => {
      console.error(`
${name}: ${message}`);
    };
    this.silent = silent;
  }
};

// src/options.ts
import fs from "fs";
import path from "path";
import process2 from "process";
import git from "isomorphic-git";

// src/git.ts
var parseRemoteUrl = (url) => {
  if (url.startsWith("https://") || url.startsWith("http://")) {
    const _url = new URL(url);
    const serverUrl = _url.origin;
    const matched2 = _url.pathname.match(/\/([^/]+\/[^/]+).git$/);
    const repository2 = matched2 !== null && matched2.length >= 1 ? matched2[1] : void 0;
    if (repository2 === void 0) {
      throw new Error(`cannot parse repository from URL: ${url}`);
    }
    return { serverUrl, repository: repository2 };
  }
  const matched = url.match(/git@(.+):([^/]+\/[^/]+).git/);
  const hostname = matched !== null && matched.length >= 2 ? matched[1] : void 0;
  const repository = matched !== null && matched.length >= 2 ? matched[2] : void 0;
  if (hostname === void 0) {
    throw new Error(`cannot parse hostname from URL: ${url}`);
  }
  if (repository === void 0) {
    throw new Error(`cannot parse repository from URL: ${url}`);
  }
  return { serverUrl: `https://${hostname}`, repository };
};

// src/options.ts
var buildTitle = (title) => {
  var _a;
  return (_a = title != null ? title : process2.env.VITEST_JUNIT_SUITE_NAME) != null ? _a : "Test Report";
};
var getVitestConfigOutputFile = (config) => {
  var _a;
  if (typeof (config == null ? void 0 : config.outputFile) === "string")
    return config.outputFile;
  return (_a = config == null ? void 0 : config.outputFile) == null ? void 0 : _a.markdown;
};
var buildPermalinkBaseUrl = (_0) => __async(void 0, [_0], function* ({
  permalinkBaseUrl,
  viteRootDir,
  log
}) {
  if (permalinkBaseUrl) {
    return permalinkBaseUrl;
  }
  if (process2.env.GITHUB_ACTIONS) {
    if (!process2.env.GITHUB_SERVER_URL || !process2.env.GITHUB_REPOSITORY || !process2.env.GITHUB_SHA || !process2.env.GITHUB_WORKSPACE) {
      throw new Error(
        "The following environment variables are required for the GitHub Actions environment\n- GITHUB_SERVER_URL\n- GITHUB_REPOSITORY\n- GITHUB_SHA\n- GITHUB_WORKSPACE"
      );
    }
    const serverUrl = process2.env.GITHUB_SERVER_URL;
    const repository = process2.env.GITHUB_REPOSITORY;
    const commit = process2.env.GITHUB_SHA;
    const rootDir2 = process2.env.GITHUB_WORKSPACE;
    const subtree = path.relative(rootDir2, viteRootDir);
    const trailingSlash = subtree.length > 0 && !subtree.endsWith("/") ? "/" : "";
    return `${serverUrl}/${repository}/blob/${commit}/${subtree}${trailingSlash}`;
  }
  const rootDir = yield git.findRoot({ fs, filepath: viteRootDir }).then((dir) => dir).catch(() => __async(void 0, null, function* () {
    return void 0;
  }));
  if (rootDir === void 0) {
    log.info("permalink disabled because project is not a git repository");
    return void 0;
  }
  try {
    const remotes = yield git.listRemotes({ fs, dir: rootDir });
    if (remotes.length === 0) {
      log.error("no remote URL found.");
      return void 0;
    }
    const remote = remotes[0];
    if (!remote)
      return void 0;
    const { serverUrl, repository } = parseRemoteUrl(remote.url);
    const commit = yield git.resolveRef({ fs, dir: rootDir, ref: "HEAD" });
    const subtree = path.relative(rootDir, viteRootDir);
    const trailingSlash = subtree.length > 0 && !subtree.endsWith("/") ? "/" : "";
    return `${serverUrl}/${repository}/blob/${commit}/${subtree}${trailingSlash}`;
  } catch (e) {
    log.error(e);
    return void 0;
  }
});

// src/report/converter.ts
import path2 from "path";
import { getSuites, getTests } from "@vitest/runner/utils";
var convertResultsToReport = (files, startTime, title, viteRootDir) => {
  const summary2 = convertSummary(files, startTime);
  files.sort((a, b) => a.name.localeCompare(b.name));
  const testFiles = files.map((file) => convertTestFile(file, viteRootDir));
  return {
    title,
    summary: summary2,
    testFiles
  };
};
var convertSummary = (files, startTime) => {
  const totalRunTime = (Date.now() - startTime) / 1e3;
  const suites = getSuites(files);
  const numPassedTestSuites = suites.filter((s) => {
    var _a;
    return ((_a = s.result) == null ? void 0 : _a.state) === "pass";
  }).length;
  const numFailedTestSuites = suites.filter((s) => {
    var _a;
    return (_a = s.result) == null ? void 0 : _a.errors;
  }).length;
  const numSkippedTestSuites = suites.filter((s) => s.mode === "skip").length;
  const numTodoTestSuites = suites.filter((s) => s.mode === "todo").length;
  const numTotalTestSuites = suites.length;
  const tests = getTests(files);
  const numPassedTests = tests.filter((t) => {
    var _a;
    return ((_a = t.result) == null ? void 0 : _a.state) === "pass";
  }).length;
  const numFailedTests = tests.filter((t) => {
    var _a;
    return ((_a = t.result) == null ? void 0 : _a.state) === "fail";
  }).length;
  const numSkippedTests = tests.filter((t) => t.mode === "skip").length;
  const numTodoTests = tests.filter((t) => t.mode === "todo").length;
  const numTotalTests = tests.length;
  return {
    numPassedTests,
    numFailedTests,
    numTotalTests,
    numPassedTestSuites,
    numFailedTestSuites,
    numSkippedTestSuites,
    numTodoTestSuites,
    numTotalTestSuites,
    numSkippedTests,
    numTodoTests,
    startTime,
    totalRunTime
  };
};
var getTaskState = (task) => {
  var _a, _b;
  return task.type === "suite" ? suiteState(task) : (_b = (_a = task.result) == null ? void 0 : _a.state) != null ? _b : task.mode;
};
var suiteState = (suite) => {
  var _a;
  if ((_a = suite.result) == null ? void 0 : _a.state)
    return suite.result.state;
  if (suite.tasks.some((task) => getTaskState(task) === "fail")) {
    return "fail";
  } else if (suite.tasks.some((task) => getTaskState(task) === "run")) {
    return "run";
  } else if (suite.tasks.every((task) => getTaskState(task) === "skip")) {
    return "skip";
  } else if (suite.tasks.every((task) => getTaskState(task) === "todo")) {
    return "todo";
  } else if (suite.tasks.every((task) => getTaskState(task) === "only")) {
    return "only";
  }
  return "pass";
};
var convertTestFile = (file, viteRootDir) => {
  var _a;
  const filePath = path2.relative(viteRootDir, file.filepath);
  const duration = ((_a = file.result) == null ? void 0 : _a.duration) || 0;
  const tests = getTests([file]);
  const numPassingTests = tests.filter((t) => {
    var _a2;
    return ((_a2 = t.result) == null ? void 0 : _a2.state) === "pass";
  }).length;
  const numFailingTests = tests.filter((t) => {
    var _a2;
    return ((_a2 = t.result) == null ? void 0 : _a2.state) === "fail";
  }).length;
  const numSkippedTests = tests.filter((t) => t.mode === "skip").length;
  const numTodoTests = tests.filter((t) => t.mode === "todo").length;
  return __spreadValues({
    filePath,
    numPassingTests,
    numFailingTests,
    numSkippedTests,
    numTodoTests,
    duration
  }, getSuiteResult(file));
};
var getTestResult = (test) => {
  return {
    name: test.name,
    state: getTaskState(test)
  };
};
var getSuiteResult = (suite) => {
  return {
    name: suite.name,
    state: suiteState(suite),
    suites: suite.tasks.filter((t) => t.type === "suite").map(getSuiteResult),
    tests: suite.tasks.filter((t) => t.type !== "suite").map(getTestResult)
  };
};

// src/report/printer.ts
var printReport = (report, options) => {
  const resultText = [`# ${report.title}`];
  resultText.push(printSummary(report.summary));
  resultText.push(printTestFiles(report.testFiles, options));
  return resultText.join("\n\n") + "\n";
};
var printSummary = (summary2) => {
  const resultText = [];
  const startTime = new Date(summary2.startTime);
  resultText.push("| \u{1F559} Start time | \u231B Duration |");
  resultText.push("| --- | ---: |");
  resultText.push(`| ${startTime.toLocaleString().replace("\u202F", " ")} | ${summary2.totalRunTime} s |
`);
  resultText.push("| | \u2705 Passed | \u274C Failed | \u23E9 Skipped | \u{1F6A7} Todo | \u26AA Total |");
  resultText.push("| --- | ---: | ---: | ---: | ---: | ---: |");
  resultText.push(
    `|Test Suites|${summary2.numPassedTestSuites}|${summary2.numFailedTestSuites}|${summary2.numSkippedTestSuites}|${summary2.numTodoTestSuites}|${summary2.numTotalTestSuites}|`
  );
  resultText.push(
    `|Tests|${summary2.numPassedTests}|${summary2.numFailedTests}|${summary2.numSkippedTests}|${summary2.numTodoTests}|${summary2.numTotalTests}|`
  );
  return resultText.join("\n");
};
var printTestFiles = (testFiles, options) => {
  const resultText = [];
  for (const [index, file] of testFiles.entries()) {
    const state = printState(file.state);
    const headerText = `<a id="file${index}" href="#file${index}">${file.filePath}</a>`;
    const link = options.permalinkBaseUrl ? ` [[link](${options.permalinkBaseUrl + file.filePath})]` : "";
    resultText.push(`## ${state} ${headerText}${link}`);
    resultText.push(
      `${file.numPassingTests} passed, ${file.numFailingTests} failed, ${file.numSkippedTests} skipped, ${file.numTodoTests} todo, done in ${file.duration} s`
    );
    const tests = file.tests.map(printTestResult);
    const suites = options.flat ? file.suites.flatMap(flattenSuite) : file.suites;
    const printedSuites = suites.map((suite) => printSuiteResult(suite));
    resultText.push("```\n" + [...tests, ...printedSuites].join("\n") + "\n```");
  }
  return resultText.join("\n\n");
};
var flattenSuite = (suite) => {
  const suites = suite.suites.map((s) => __spreadProps(__spreadValues({}, s), { name: suite.name + " \u203A " + s.name })).flatMap(flattenSuite);
  return [...suites, __spreadProps(__spreadValues({}, suite), { suites: [] })];
};
var printTestResult = (test) => `${printState(test.state)} ${test.name}`;
var printSuiteResult = (suite, level = 1) => {
  const suites = suite.suites.map((s) => "   ".repeat(level) + printSuiteResult(s, level + 1));
  const tests = suite.tests.map((t) => "   ".repeat(level) + printTestResult(t));
  const title = printTestResult(suite);
  return [title, ...tests, ...suites].join("\n");
};
var printState = (state) => {
  switch (state) {
    case "pass":
      return "\u2705";
    case "fail":
      return "\u274C";
    case "skip":
      return "\u23E9";
    case "todo":
      return "\u{1F6A7}";
    case "only":
      return "\u2B50";
    default:
      return "??";
  }
};

// src/index.ts
var existsSync = (path3) => {
  try {
    accessSync(path3);
    return true;
  } catch (e) {
    return false;
  }
};
var VitestMarkdownReporter = class {
  constructor(reporterOptions = {}) {
    this.reporterOptions = reporterOptions;
    this.start = 0;
    this.onFinished = (..._0) => __async(this, [..._0], function* (files = []) {
      var _a, _b;
      const title = buildTitle(this.reporterOptions.title);
      const permalinkBaseUrl = yield buildPermalinkBaseUrl({
        permalinkBaseUrl: this.reporterOptions.permalinkBaseUrl,
        viteRootDir: this.ctx.config.root,
        log: this.log
      });
      const flat = (_a = this.reporterOptions.flat) != null ? _a : true;
      const report = convertResultsToReport(files, this.start, title, process.cwd());
      const reportText = printReport(report, { flat, permalinkBaseUrl });
      const outputPath = (_b = this.reporterOptions.outputPath) != null ? _b : getVitestConfigOutputFile(this.ctx.config);
      if (outputPath) {
        const reportFile = resolve(this.ctx.config.root, outputPath);
        const outputDirectory = dirname(reportFile);
        if (!existsSync(outputDirectory))
          yield mkdir(outputDirectory, { recursive: true });
        yield writeFile(reportFile, reportText, "utf-8");
        this.ctx.logger.log(`Markdown report written to ${reportFile}`);
      } else {
        this.ctx.logger.log(reportText);
      }
      if (process.env.GITHUB_ACTIONS && this.reporterOptions.enableGithubActionsSummary) {
        summary.addRaw(reportText);
        summary.write();
      }
    });
    var _a, _b;
    this.log = new Logger();
    (_b = (_a = this.reporterOptions).enableGithubActionsSummary) != null ? _b : _a.enableGithubActionsSummary = true;
  }
  onInit(ctx) {
    this.ctx = ctx;
    this.start = Date.now();
  }
};
var src_default = VitestMarkdownReporter;
export {
  VitestMarkdownReporter,
  src_default as default
};
